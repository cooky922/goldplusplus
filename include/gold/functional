// <gold/functional> - gold++ library

// Copyright (C) 2021 - present Desmond Gold

#pragma once
#ifndef __GOLD_FUNCTIONAL
#define __GOLD_FUNCTIONAL

#include <functional>

#include <gold/bits/tuple/tuple_util.hpp>

namespace gold {

    /// unref - unwrapping reference wrapper object by calling get, otherwise it will be forwarded
    template <typename T>
    constexpr T&& unref(T&& t) {
        return std::forward<T>(t);
    }

    template <typename T>
    constexpr T& unref(std::reference_wrapper<T> t) {
        return t.get();
    }

    namespace __requirements {

        template <typename... Ts>
        concept has_at_least_ref_wrapper_ = (__detail::is_ref_wrapper_v_<std::remove_cvref_t<Ts>> || ...);

    }

    /// overloaded
    template <typename... Fs>
    struct overloaded : Fs... {

        /// C++ 17 feature, bringing all 'operator()' into here
        using Fs::operator()...;

        /// automatic reference wrapper unwrapping
        template <typename... Ts>
            requires __requirements::has_at_least_ref_wrapper_<Ts...>
        constexpr auto operator()(Ts&&... args) noexcept {
            return (*this)(unref(std::forward<Ts>(args))...);
        }

    };

    /// deduction guide for overloaded class template
    template <typename... Fs>
    overloaded(Fs...) -> overloaded<Fs...>;

    /// overload
    template <typename... Ts>
    constexpr auto overload(Ts&&... args) noexcept {
        return overloaded{std::forward<Ts>(args)...};
    }

    /// bind_back - such that bind_back(f, args_0...)(args_1...) == f(args_1..., args_0...)
    template <typename F, typename... Args>
    constexpr auto bind_back(F&& f, Args&&... args) {
        return [
            f = std::forward<F>(f),
            ...args = std::forward<Args>(args)
        ]<typename... Ts>(Ts&&... first_args) {
            return std::invoke(
                f, std::forward<Ts>(first_args)..., args...
            );
        };
    }

    /// bind_rest
    template <typename F, typename... Args>
    constexpr auto bind_rest(F&& f, Args&&... args) {
        return [f = std::forward<F>(f), ...args = std::forward<Args>(args)]<typename T>(T&& arg) {
            return std::invoke(
                f, std::forward<T>(arg), args...
            );
        };
    }

} // namespace gold

#endif // __GOLD_FUNCTIONAL

