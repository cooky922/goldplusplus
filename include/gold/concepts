// <gold/concepts> - gold++ library

// Copyright (C) 2021 - present Desmond Gold

#pragma once
#ifndef __GOLD_CONCEPTS
#define __GOLD_CONCEPTS

#include <string_view>
#include <iosfwd>
#include <concepts>
#include <bits/stringfwd.h>
#include <bits/ranges_base.h>

#include <gold/type_traits>
#include <gold/bits/concepts/types.hpp>
#include <gold/bits/typeof/compile_typeof.hpp>

namespace gold {

    /// enable_qualified_string
    template <typename T>
    inline constexpr bool enable_qualified_string = false;

    template <typename CharT, typename Traits, typename Alloc>
    inline constexpr bool enable_qualified_string<std::basic_string<CharT, Traits, Alloc>> = true;

    template <typename CharT, typename Traits>
    inline constexpr bool enable_qualified_string<std::basic_string_view<CharT, Traits>> = true;

    /// qualified_basic_string
    template <typename T, typename C>
    concept qualified_basic_string =
        (std::is_array_v<std::remove_cvref_t<T>>
        && std::same_as<C, std::remove_cvref_t<std::remove_extent_t<std::remove_cvref_t<T>>>>)
     || (std::is_pointer_v<std::remove_cvref_t<T>>
        && std::same_as<C, std::remove_cvref_t<std::remove_pointer_t<std::remove_cvref_t<T>>>>)
     || (std::convertible_to<T, std::basic_string_view<C>>
        && enable_qualified_string<T>)
     && char_type<C>;

    /// qualified_string
    template <typename T>
    concept qualified_string = qualified_basic_string<T, char>;

    /// qualified_wstring
    template <typename T>
    concept qualified_wstring = qualified_basic_string<T, wchar_t>;

    /// basic_stream_insertable
    template <typename T, typename CharT, typename Traits = std::char_traits<CharT>>
    concept basic_stream_insertable = requires (std::basic_ostream<CharT, Traits>& os, const T& t) {
        {(os << t)} -> std::same_as<std::basic_ostream<CharT, Traits>&>;
    } && char_type<CharT>;

    /// basic_stream_extractable
    template <typename T, typename CharT, typename Traits = std::char_traits<CharT>>
    concept basic_stream_extractable = requires (std::basic_istream<CharT, Traits>& is, T& t) {
        {(is >> t)} -> std::same_as<std::basic_istream<CharT, Traits>&>;
    } && char_type<CharT>;

    /// stream_insertable
    template <typename T>
    concept stream_insertable = basic_stream_insertable<T, char>;

    /// wstream_insertable
    template <typename T>
    concept wstream_insertable = basic_stream_insertable<T, wchar_t>;

    /// stream_extractable
    template <typename T>
    concept stream_extractable = basic_stream_extractable<T, char>;

    /// wstream_extractable
    template <typename T>
    concept wstream_extractable = basic_stream_extractable<T, wchar_t>;

    /// range_basic_stream_insertable
    template <typename T, typename C>
    concept range_basic_stream_insertable =
        std::ranges::range<T>
     && std::ranges::sized_range<T>
     && !qualified_basic_string<T, C>
     && basic_stream_insertable<std::ranges::range_value_t<T>, C>
     && char_type<C>;

    /// range_stream_insertable
    template <typename T>
    concept range_stream_insertable = range_basic_stream_insertable<T, char>;

    /// range_wstream_insertable
    template <typename T>
    concept range_wstream_insertable = range_basic_stream_insertable<T, wchar_t>;

    namespace __detail {

        template <typename T>
        consteval bool is_anonymous_func_() {
            constexpr auto name_ = gold::__detail::compile_type_of_<T>();

            if (name_.contains("<lambda closure object>")) return false;
            return name_.contains("<lambda(");
        }

    } // namespace __detail

    /// lambda
    template <typename T>
    concept lambda = __detail::is_anonymous_func_<T>();

} // namespace gold

#endif // __GOLD_CONCEPTS
