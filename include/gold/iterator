// <gold/iterator> - gold++ library

// Copyright (C) 2021 - present Desmond Gold

#pragma once
#ifndef __GOLD_ITERATOR
#define __GOLD_ITERATOR

#include <concepts>
#include <iterator>

namespace gold {

    /// counting_iterator - note: different from 'std::counted_iterator'
    template <typename T>
    class counting_iterator {
      public:
        using iterator_category = std::output_iterator_tag;
        using value_type        = void;
        using difference_type   = std::ptrdiff_t;
        using pointer           = void;
        using reference         = void;

      private:
        std::size_t m_count_ { 0 };

      public:
        constexpr counting_iterator() = default;
        constexpr counting_iterator& operator=(const T&) noexcept { return *this; }
        constexpr counting_iterator& operator=(T&&) noexcept { return *this; }

        constexpr counting_iterator& operator*() noexcept { return *this; }
        constexpr counting_iterator& operator++() noexcept { ++m_count_; return *this; }
        constexpr counting_iterator operator++(int) noexcept {
            auto temp = *this;
            ++*this;
            return temp;
        }
        constexpr std::size_t count() const noexcept { return m_count_; }
        constexpr void reset() noexcept { m_count_ = 0; }
    };

    /// coop_counting_iterator
    template <typename Iter>
    class coop_counting_iterator {
      public:
        using iterator_category = std::output_iterator_tag;
        using base_type         = Iter;
        using value_type        = std::iter_value_t<Iter>;
        using difference_type   = std::iter_difference_t<Iter>;
        using reference         = std::iter_reference_t<Iter>;
        using pointer           = std::iterator_traits<Iter>::pointer;

      private:
        base_type m_base_;
        std::size_t m_count_ { 0 };

      public:
        constexpr coop_counting_iterator() = default;
        explicit constexpr coop_counting_iterator(Iter iter) : m_base_(std::move(iter)) {}

        constexpr coop_counting_iterator& operator++() noexcept {
            ++m_base_, ++m_count_;
            return *this;
        }

        constexpr coop_counting_iterator operator++(int) noexcept {
            auto temp = *this;
            ++*this;
            return temp;
        }

        constexpr reference operator*() const noexcept { return *m_base_; }

        constexpr pointer operator->() const noexcept {
            if constexpr (std::is_pointer_v<Iter>)
                return m_base_;
            else
                return m_base_.operator->();
        }

        constexpr base_type base() const noexcept { return m_base_; }

        constexpr std::size_t count() const noexcept { return m_count_; }

        constexpr void reset() noexcept { m_count_ = 0; }
    };

    /// deduction guide for 'coop_counting_iterator'
    template <typename Iter>
    coop_counting_iterator(Iter) -> coop_counting_iterator<Iter>;

} // namespace gold

#endif // __GOLD_ITERATOR
