// <gold/math_int>

// Copyright (C) 2021 - present Desmond Gold

#pragma once
#ifndef __GOLD_MATH_INT
#define __GOLD_MATH_INT

/// integer math library - safe math integer functions

#include <bit>
#include <numeric>
#include <gold/utility>

namespace gold::math {

    /// midpoint
    template <std::integral T>
    inline constexpr T midpoint(const T& a, const T& b) {
        return (a & b) + ((a ^ b) >> 1);
    }

    /// signum
    template <std::integral T>
    inline constexpr int signum(const T& a) noexcept {
        if constexpr (std::is_unsigned_v<T>)
            return T(0) < a;
        else
            return (T(0) < a) - (a < T(0));
    }

    /// power
    template <std::integral T>
    inline constexpr T power(T base, std::size_t expo) {
        // exponent 0 case: base ^ 0 = 1
        if (expo == 0) return 1;

        // exponent 1 case: base ^ 1 = base
        if (expo == 1) return base;

        // base -1 case
        if constexpr (std::is_signed_v<T>) {
            if (base == static_cast<T>(-1))
                return (expo & 1) ? static_cast<T>(-1) : static_cast<T>(1);
        }

        // base 2 case
        if (base == static_cast<T>(2))
            return static_cast<T>(1) << expo;

        // normal case
        T result = 1;

        while (expo) {
            // if exponent is odd
            if (expo & 1) result *= base;
            // divide exponent by 2
            expo >>= 1;
            // multiply itself
            base *= base;
        }

        return result;
    }

    /// log_2
    template <std::integral T>
    inline constexpr T log_2(const T& x) {
        return std::bit_width(gold::to_unsigned(x)) - 1;
    }

    /// square_root
    template <std::integral T>
    inline constexpr T square_root(const T& a) {
        std::uint64_t l = 0, r = a;
        return [&, a = static_cast<std::uint64_t>(a)] constexpr -> T {
            while (l <= r) [[likely]] {
                auto mid_ = midpoint(l, r);
                auto mid_2_ = mid_ * mid_;

                if ((mid_2_ <= a) && (a < (mid_ + 1) * (mid_ + 1)))
                    return mid_;

                (mid_2_ > a ? r : l) = mid_ + (mid_2_ > a ? -1 : 1);
            }
            __builtin_unreachable();
        }();
    }

    /// cube_root
    template <std::integral T>
    inline constexpr T cube_root(const T& x) {
        /// conversion to 64-bit unsigned int
        std::uint64_t n = static_cast<std::uint64_t>(x), r0 = 1, r1;

        /// 0 ^ (1/3) == 0
        if (n == 0) return 0;

        int b = 64 - std::countl_zero(n);
        r0 <<= (b + 2) / 3;

        do {
            r1 = std::move(r0);
            r0 = (2 * r1 + n / (r1 * r1)) / 3;
        } while (r0 < r1);

        return static_cast<T>(r1);
    }

    /// is_prime
    template <std::integral T>
    inline constexpr bool is_prime(const T& n) {
        if (n == 0 || n == 1 || n < 0)
            return false;
        for (auto i = 2; i <= (n / 2); ++i) {
            if (n % i == 0)
                return false;
        }
        return true;
    }

    /// are_co_prime
    template <std::integral T>
    inline constexpr bool are_co_prime(const T& a, const T& b) {
        return std::gcd(a, b) == 1;
    }

    /// factorial - must be unsigned :>
    template <std::unsigned_integral T = std::uintmax_t>
    inline constexpr T factorial(const T& n) {
        T result = 1;
        for (T i = 2; i <= n; ++i)
            result *= i;
        return result;
    }

    /// permutation
    template <std::unsigned_integral T = std::uintmax_t>
    inline constexpr T permutation(const T& n, const T& k) {
        return factorial(n) / factorial(n - k);
    }

    /// combination
    template <std::unsigned_integral T = std::uintmax_t>
    inline constexpr T combination(const T& n, const T& k) {
        return factorial(n) / (factorial(k) * factorial(n - k));
    }

    /// binomial_coeff - synonym to combination
    template <std::unsigned_integral T = std::uintmax_t>
    inline constexpr T binomial_coeff(const T& n, const T& k) {
        return combination(n, k);
    }

    /// digit_count
    template <std::integral T>
    inline constexpr T digit_count(const T& a) {
        auto b = static_cast<unsigned long long>(a > 0 ? a : -a);
        return (
            b < power(10ull, 1) ? 1 :
            b < power(10ull, 2) ? 2 :
            b < power(10ull, 3) ? 3 :
            b < power(10ull, 4) ? 4 :
            b < power(10ull, 5) ? 5 :
            b < power(10ull, 6) ? 6 :
            b < power(10ull, 7) ? 7 :
            b < power(10ull, 8) ? 8 :
            b < power(10ull, 9) ? 9 :
            b < power(10ull, 10) ? 10 :
            10 + digit_count(b / power(10ull, 10))
        );
    }

} // namespace gold::math

#endif // __GOLD_MATH_INT
