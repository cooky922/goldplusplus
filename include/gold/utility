// <gold/utility> - gold++ library

// Copyright (C) [ 2021 - 2022 ] - present Desmond Gold

#pragma once
#ifndef __GOLD_UTILITY
#define __GOLD_UTILITY

#include <utility>
#include <gold/concepts>
#include <gold/bits/extents.hpp>
#include <gold/bits/in_place.hpp>
#include <gold/bits/enum_ops.hpp>

namespace gold {

    /// dynamic_extent_t [ defined in <gold/bits/extents.hpp> ]
    /// dynamic_extent   [ defined in <gold/bits/extents.hpp> ]
    /// extent_t         [ defined in <gold/bits/extents.hpp> ]

    /// in_place_braced_t       [ defined in <gold/bits/in_place.hpp> ]
    /// in_place_braced         [ defined in <gold/bits/in_place.hpp> ]
    /// in_place_type_braced_t  [ defined in <gold/bits/in_place.hpp> ]
    /// in_place_type_braced    [ defined in <gold/bits/in_place.hpp> ]
    /// in_place_index_braced_t [ defined in <gold/bits/in_place.hpp> ]
    /// in_place_index_braced   [ defined in <gold/bits/in_place.hpp> ]
    /// in_place_value_t        [ defined in <gold/bits/in_place.hpp> ]
    /// in_place_value          [ defined in <gold/bits/in_place.hpp> ]
    /// in_place_value_braced_t [ defined in <gold/bits/in_place.hpp> ]
    /// in_place_value_braced   [ defined in <gold/bits/in_place.hpp> ]

    /// enum_ops::enable_enum_ops [ defined in <gold/bits/enum_ops.hpp> ]
    /// bitwise operators for scoped enums in namespace 'gold::enum_ops'

    /// to_unsigned
    template <std::integral T>
    constexpr auto to_unsigned(const T& arg) {
        return static_cast<std::make_unsigned_t<T>>(arg);
    }

    /// to_signed
    template <std::integral T>
    constexpr auto to_signed(const T& arg) {
        return static_cast<std::make_signed_t<T>>(arg);
    }

    /// as_consteval
    consteval auto as_consteval(const auto& arg) { return arg; }

    /// unmove
    template <typename T>
    [[nodiscard]] constexpr std::remove_reference_t<T>& unmove(T&& t) { return t; }

    /// unforward
    template <typename T>
        requires std::constructible_from<std::remove_reference_t<T>, T&&>
    [[nodiscard]] constexpr std::remove_reference_t<T>&
    unforward(T&& t)
        noexcept(std::is_nothrow_constructible_v<std::remove_reference_t<T>, T&&>)
    {
        return std::forward<T>(t);
    }

    /// decay_copy
    template <typename T>
        requires std::copy_constructible<std::decay_t<T>>
    [[nodiscard]] constexpr auto decay_copy(T&& t)
        noexcept(std::is_nothrow_convertible_v<T, std::decay_t<T>>)
    {
        return auto(std::forward<T>(t));
    }

    /// decay_move
    template <typename T>
        requires std::move_constructible<std::decay_t<T>>
    [[nodiscard]] constexpr auto decay_move(T&& t)
        noexcept(std::is_nothrow_convertible_v<T, std::decay_t<T>>)
    {
        return auto(std::move(t));
    }

    namespace __utility {

        template <typename T, typename U>
        using forwarded_like_type = std::conditional_t<
            std::is_lvalue_reference_v<T>,
            std::remove_reference_t<U>&,
            std::remove_reference_t<U>&&
        >;

    } // namespace __utility

    /// forward_like
    template <typename T, typename U>
    constexpr __utility::forwarded_like_type<T, U> forward_like(U&& arg) noexcept {
        return std::forward<__utility::forwarded_like_type<T, U>>(std::forward<U>(arg));
    }

    /// discard_unused
    constexpr void discard_unused(...) noexcept {}

    template <typename...>
    constexpr void discard_unused() noexcept {}

    /// unreachable
    [[noreturn]] constexpr void unreachable() { __builtin_unreachable(); }

} // namespace gold

#endif // __GOLD_UTILITY
