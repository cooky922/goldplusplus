// <gold/unique_ptr> - gold++ library

// Copyright (C) 2021 - present Desmond Gold

#pragma once
#ifndef __GOLD_UNIQUE_PTR
#define __GOLD_UNIQUE_PTR

/// note: use 'std::unique_ptr' instead for runtime version.
/// this implementation is intended to be used at compile-time
/// this feature can be removed once 'std::unique_ptr' is constexpr

#include <utility>
#include <bits/ranges_algobase.h>
#include <gold/bits/concepts/types.hpp>
#include <gold/assertion>

namespace gold {

    /// default_delete [ for single object ]
    template <typename T>
    struct default_delete {
        constexpr default_delete() noexcept = default;

        template <typename U>
            requires std::convertible_to<U*, T*>
        constexpr default_delete(const default_delete<U>&) noexcept {}

        constexpr void operator()(T* ptr) const
            requires gold::complete_type<T>
        {
            delete ptr;
        }
    };

    /// default_delete [ for array ]
    template <typename T>
    struct default_delete<T[]> {
        constexpr default_delete() noexcept = default;

        template <typename U>
            requires std::convertible_to<U(*)[], T(*)[]>
        constexpr default_delete(const default_delete<U[]>&) noexcept {}

        constexpr void operator()(T* ptr) const
            requires gold::complete_type<T>
        {
            delete[] ptr;
        }
    };

    /// unique_ptr [ for single object ]
    template <typename T, typename D = default_delete<T>>
    class unique_ptr {
      public:
        using pointer      = T*;
        using element_type = T;
        using deleter_type = D;

      private:
        pointer m_data_ { nullptr };
        [[no_unique_address]] deleter_type m_deleter_ { };

        template <typename Tp, typename Dp>
        inline static constexpr bool is_safe_conversion_up_v_ = std::is_convertible_v<
            typename unique_ptr<Tp, Dp>::pointer, pointer
        > && ! std::is_array_v<Tp>;


      public:
        //// Constructors
        /// explicit constructor [concrete type]
        explicit constexpr unique_ptr(element_type* data_)
        : m_data_(data_) {}

        explicit constexpr unique_ptr(element_type* data_, deleter_type deleter_)
        : m_data_(data_), m_deleter_(deleter_) {}

        /// explicit constructor for derived type
        template <std::derived_from<element_type> U>
        explicit constexpr unique_ptr(U* data_)
        : m_data_(data_) {}

        template <std::derived_from<element_type> U>
        explicit constexpr unique_ptr(U* data_, deleter_type deleter_)
        : m_data_(data_), m_deleter_(deleter_) {}

        /// default constructor
        constexpr unique_ptr() = default;

        /// null pointer constructor
        constexpr unique_ptr(std::nullptr_t) : unique_ptr() {}

        /// deleted copy constructor
        constexpr unique_ptr(const unique_ptr&) = delete;

        /// move constructor
        constexpr unique_ptr(unique_ptr&& other_) noexcept
        : m_data_(std::exchange(other_.m_data_, nullptr)) {}

        /// derived class move constructor
        template <std::derived_from<element_type> U>
        constexpr unique_ptr(unique_ptr<U>&& other_) noexcept
        : m_data_(other_.release()) {}

        /// destructor
        constexpr ~unique_ptr() { if (*this) m_deleter_(m_data_); }

        //// Assignments
        /// null pointer assignment
        constexpr unique_ptr& operator=(std::nullptr_t) {
            reset();
            return *this;
        }

        /// deleted copy assignment
        constexpr unique_ptr& operator=(const unique_ptr&) = delete;

        /// move assignment
        constexpr unique_ptr& operator=(unique_ptr&& other_) noexcept {
            if (this != &other_)
                m_data_ = std::exchange(other_.m_data_, nullptr);
            return *this;
        }

        /// derived class move assignment
        template <std::derived_from<element_type> U>
        constexpr unique_ptr& operator=(unique_ptr<U>&& other_) noexcept {
            m_data_ = other_.release();
            return *this;
        }

        //// Observers
        /// operator->
        constexpr pointer operator->() const noexcept {
            gold::system_assert(m_data_ != nullptr);
            return m_data_;
        }

        /// operator*
        constexpr element_type& operator*() const noexcept {
            gold::system_assert(m_data_ != nullptr);
            return *m_data_;
        }

        /// get_deleter
        constexpr deleter_type get_deleter() const noexcept { return m_deleter_; }

        /// get
        constexpr pointer get() const noexcept { return m_data_; }

        /// operator bool
        explicit constexpr operator bool() const noexcept { return m_data_ != nullptr; }

        //// Modifiers
        /// swap
        constexpr void swap(unique_ptr& other_) noexcept {
            using std::swap;
            swap(m_data_, other_.m_data_);
            swap(m_deleter_, other_.m_deleter_);
        }

        /// release
        constexpr pointer release() noexcept {
            return std::exchange(m_data_, nullptr);
        }

        /// reset
        constexpr void reset(pointer item_ = {}) noexcept {
            auto temp_ = release();
            if (temp_ != nullptr) m_deleter_(temp_);
            m_data_ = item_;
        }

        //// Comparisons
        /// operator==
        constexpr bool operator==(const unique_ptr& other_) const noexcept {
            return m_data_ == other_.m_data_;
        }

        /// operator<=>
        constexpr std::strong_ordering operator<=>(const unique_ptr& other_) const noexcept {
            return m_data_ <=> other_.m_data_;
        }

    };

    /// unique_ptr [ for array ]
    template <typename T, typename Dp>
    class unique_ptr<T[], Dp> {
      public:
        using element_type = T;
        using pointer      = T*;
        using deleter_type = Dp;

      private:
        pointer m_data_ { nullptr };
        [[no_unique_address]] deleter_type m_deleter_ {};

      public:
        //// Constructors
        /// explicit constructor [concrete type]
        explicit constexpr unique_ptr(element_type* data_)
        : m_data_(data_) {}

        explicit constexpr unique_ptr(element_type* data_, deleter_type deleter_)
        : m_data_(data_), m_deleter_(deleter_) {}

        /// explicit constructor for derived type
        template <std::derived_from<element_type> U>
        explicit constexpr unique_ptr(U* data_)
        : m_data_(data_) {}

        template <std::derived_from<element_type> U>
        explicit constexpr unique_ptr(U* data_, deleter_type deleter_)
        : m_data_(data_), m_deleter_(deleter_) {}

        /// default constructor
        constexpr unique_ptr() = default;

        /// null pointer constructor
        constexpr unique_ptr(std::nullptr_t) : unique_ptr() {}

        /// deleted copy constructor
        constexpr unique_ptr(const unique_ptr&) = delete;

        /// move constructor
        constexpr unique_ptr(unique_ptr&& other_) noexcept
        : m_data_(std::exchange(other_.m_data_, nullptr)) {}

        /// derived class move constructor
        template <std::derived_from<element_type> U>
        constexpr unique_ptr(unique_ptr<U>&& other_) noexcept
        : m_data_(std::exchange(other_.m_data_, nullptr)) {}

        /// destructor
        constexpr ~unique_ptr() { if (*this) m_deleter_(m_data_); }

        //// Assignments
        /// null pointer assignment
        constexpr unique_ptr& operator=(std::nullptr_t) {
            reset();
            return *this;
        }

        /// deleted copy assignment
        constexpr unique_ptr& operator=(const unique_ptr&) = delete;

        /// move assignment
        constexpr unique_ptr& operator=(unique_ptr&& other_) noexcept {
            if (this != &other_)
                m_data_ = std::exchange(other_.m_data_, nullptr);
            return *this;
        }

        /// derived class move assignment
        template <std::derived_from<element_type> U>
        constexpr unique_ptr& operator=(unique_ptr<U>&& other_) noexcept {
            m_data_ = std::exchange(other_.m_data_, nullptr);
            return *this;
        }

        //// Observers
        /// operator[]
        constexpr element_type& operator[](std::size_t i) noexcept {
            gold::system_assert(m_data_ != nullptr);
            return m_data_[i];
        }

        /// get
        constexpr pointer get() const noexcept { return m_data_; }

        /// get_deleter
        constexpr deleter_type get_deleter() const noexcept { return m_deleter_; }

        /// operator bool
        explicit constexpr operator bool() const noexcept { return m_data_ != nullptr; }

        //// Modifiers
        /// swap
        constexpr void swap(unique_ptr& other_) noexcept {
            using std::swap;
            swap(m_data_, other_.m_data_);
            swap(m_deleter_, other_.m_deleter_);
        }

        /// release
        constexpr pointer release() noexcept {
            return std::exchange(m_data_, nullptr);
        }

        /// reset
        constexpr void reset(pointer item_ = {}) noexcept {
            auto temp_ = release();
            if (temp_ != nullptr) deleter_type()(temp_);
            m_data_ = item_;
        }

        //// Comparisons
        /// operator==
        constexpr bool operator==(const unique_ptr& other_) const noexcept {
            return m_data_ == other_.m_data_;
        }

        /// operator<=>
        constexpr std::strong_ordering operator<=>(const unique_ptr& other_) const noexcept {
            return m_data_ <=> other_.m_data_;
        }
    };

    /// make_unique [ for single object ]
    template <typename T, typename... Args>
    constexpr unique_ptr<T> make_unique(Args&&... args) {
        return unique_ptr<T>(new T(std::forward<Args>(args)...));
    }

    /// make_unique [ for array ]
    template <typename T>
        requires std::is_unbounded_array_v<T>
    constexpr unique_ptr<T> make_unique(std::size_t n) {
        using type = std::remove_extent_t<T>;
        return unique_ptr<T>(new type[n]);
    }

    template <typename T>
        requires std::is_bounded_array_v<T>
    constexpr unique_ptr<std::remove_extent_t<T>[]> make_unique() {
        using type = std::remove_extent_t<T>;
        return unique_ptr<type[]>(new type[std::extent_v<T>]);
    }

    template <typename T>
        requires std::is_unbounded_array_v<T>
    constexpr unique_ptr<std::remove_extent_t<T>[]> make_unique(std::initializer_list<std::remove_extent_t<T>> arg) {
        using type = std::remove_extent_t<T>;
        auto  ptr  = new type[arg.size()];
        std::ranges::move(arg, ptr);
        return unique_ptr<type[]>(ptr);
    }

} // namespace gold

#endif // __GOLD_UNIQUE_PTR
